package writescript

import (
	"fmt"
	"github.com/fatih/color"
	"github.com/paulvollmer/go-verbose"
	"github.com/robertkrimen/otto"
	"github.com/writescript/textbackend"
	"os"
	"strings"
)

// Version of the script engine.
const Version = "0.3.2"

var (
	red    = color.New(color.FgRed).SprintFunc()
	green  = color.New(color.FgGreen).SprintFunc()
	blue   = color.New(color.FgBlue).SprintFunc()
	yellow = color.New(color.FgYellow).SprintFunc()
	cyan   = color.New(color.FgCyan).SprintFunc()
)

// WriteScript Core
type WriteScript struct {
	Content textbackend.TextContent // create output storage the plugin can write content to
}

// Process the plugin generator.
func (w *WriteScript) Process(plugin, data string, headerOn bool, debug verbose.Verbose) error {
	debug.Println("==> start execute")

	// Plugin load and import stuff...
	tmpPlugin := Plugin{}
	tmpPlugin.ParseSource(plugin)
	debug.Println("--> plugin parsed", tmpPlugin)

	// do you want to write the default header?
	if headerOn {
		debug.Println("--> create default header")
		// if no header was set, create a default header
		w.Content.Writeln("// written by writescript v" + Version)
		// w.Content.Writeln("// TODO: generated by the following command:")
		// w.Content.Writeln("//   writescript ")
		w.Content.Writeln("// DO NOT EDIT!")
		w.Content.Writeln("")
	}

	debug.Println("initialize otto")
	vm := otto.New()

	// infos about the software
	vm.Set("version", Version)

	// create api we can use at the plugin
	vm.Set("writeln", func(call otto.FunctionCall) otto.Value {
		// check if args are empty...
		if len(call.ArgumentList) == 0 {
			w.Content.Writeln("")
		} else {
			tmpLine := ""
			for _, v := range call.ArgumentList {
				val, errVal := v.ToString()
				if errVal != nil {
					fmt.Println(red("Error: cannot convert variable " + errVal.Error()))
				}
				tmpLine += val
			}
			w.Content.Writeln(tmpLine)
		}
		return otto.Value{}
	})

	vm.Set("write", func(call otto.FunctionCall) otto.Value {
		if len(call.ArgumentList) != 0 {
			tmpLine := ""
			for _, v := range call.ArgumentList {
				val, errVal := v.ToString()
				if errVal != nil {
					fmt.Println(red("Error: cannot convert variable " + errVal.Error()))
				}
				tmpLine += val
			}
			w.Content.Write(tmpLine)
		}
		return otto.Value{}
	})

	vm.Set("pushLevel", func(call otto.FunctionCall) otto.Value {
		w.Content.PushLevel()
		return otto.Value{}
	})

	vm.Set("popLevel", func(call otto.FunctionCall) otto.Value {
		w.Content.PopLevel()
		return otto.Value{}
	})

	vm.Set("getLevel", func(call otto.FunctionCall) otto.Value {
		val := w.Content.GetLevel()
		result, _ := otto.ToValue(val)
		return result
	})

	vm.Set("setLevel", func(call otto.FunctionCall) otto.Value {
		val, err := call.Argument(0).ToInteger()
		if err == nil {
			w.Content.SetLevel(uint8(val))
		} else {
			fmt.Println(red("Error", err))
		}
		}

		return otto.Value{}
	})

	// run the vm and get the result
	tmpScripts := strings.Join(tmpPlugin.ImportCodeStack, "\n") + strings.Join(tmpPlugin.Js, "\n")
	vmScript := CreateVMScript(tmpScripts, data)
	// fmt.Println("vmScript")
	// fmt.Println("====================================")
	// fmt.Println(vmScript)
	// fmt.Println("====================================")
	_, err := vm.Run(vmScript)
	if err != nil {
		return err
	}
	return nil
}

// CreateVMScript creates the javascript script we run at the otto vm.
// data must be formatted as json.
func CreateVMScript(plugin, dataJSON string) string {
	script := `function RUN(data) {
		` + plugin + `
	};`
	script += `RUN(`
	if dataJSON == "" {
		script += `{}` // if data is empty string, set it to an empty object
	} else {
		// remove linebreaks (or error at JSON.parse call)
		dataWithoutLinebreak := strings.Replace(dataJSON, "\n", "", -1)
		dataWithoutLinebreakEscapeSingleQuote := strings.Replace(dataWithoutLinebreak, `"`, `\"`, -1)
		script += `JSON.parse("` + dataWithoutLinebreakEscapeSingleQuote + `")`
	}
	script += `);`
	return script
}
